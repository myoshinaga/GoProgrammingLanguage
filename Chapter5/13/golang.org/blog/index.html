
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width">
	<meta name="theme-color" content="#375EAB">
	<title>The Go Programming Language Blog</title>
	<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">
	<link type="text/css" rel="stylesheet" href="/fonts.css">
	<link rel="alternate" type="application/atom+xml" title="blog.golang.org - Atom Feed" href="https://blog.golang.org/feed.atom" />
	<script type="text/javascript">window.initFuncs = [];</script>
	<style>
		#sidebar {
			float: right;
			padding-left: 20px;
			width: 40%;
			max-width: 250px;
			background: #F3F3F3;
			margin: 20px 0 20px 20px;
		}
		#sidebar ul {
			padding: 0;
		}
		#sidebar li {
			list-style-type: none;
		}
		#content .author {
			font-style: italic;
		}
		#content .article {
			margin-bottom: 50px;
		}
		#content .date {
			color: #999;
		}
		#content .tags {
			color: #999;
			font-size: smaller;
		}
		#content .iframe, #content .image {
			margin: 20px;
		}
		#content .title {
			margin: 20px 0;
		}
		#content img {
			max-width: 100%;
		}
		.article[data-slug='/go-fonts'] {
			font-family: Go, sans-serif;
		}
		.article[data-slug='/go-fonts'] pre,
		.article[data-slug='/go-fonts'] code {
			font-family: Go Mono, monospace;
		}
	</style>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-11222381-3"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag("js", new Date());
gtag("config", "UA-11222381-3");
gtag("config", "UA-49880327-6");
</script>
</head>
<body>

<div id="topbar"><div class="container">

<div class="top-heading" id="heading-wide"><a href="https://golang.org/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="https://golang.org/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="https://golang.org/search">
<div id="menu">
<a href="https://golang.org/doc/">Documents</a>
<a href="https://golang.org/pkg/">Packages</a>
<a href="https://golang.org/project/">The Project</a>
<a href="https://golang.org/help/">Help</a>
<a href="/">Blog</a>
<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>

<div id="page">
<div class="container">

<div id="sidebar">
	

	<h4>Links</h4>
	<ul>
	<li><a href='//golang.org/'>golang.org</a></li>
	<li><a href='//golang.org/doc/install.html'>Install Go</a></li>
	<li><a href='//tour.golang.org/'>A Tour of Go</a></li>
	<li><a href='//golang.org/doc/'>Go Documentation</a></li>
	<li><a href='//groups.google.com/group/golang-nuts'>Go Mailing List</a></li>
	<li><a href='//plus.google.com/communities/114112804251407510571'>Go+ Community</a></li>
	<li><a href='//twitter.com/golang'>Go on Twitter</a></li>
	</ul>

	<p><a href="/index">Blog index</a></p>
</div>

<div id="content">
	<h1><a href="/">The Go Blog</a></h1>
	
	
		
	<div class="article" data-slug="/survey2018-results">
		<h3 class="title"><a href="/survey2018-results">Go 2018 Survey Results</a></h3>
		<p class="date">28 March 2019</p>
		

  
  
    
      
  <h4 id="TOC_1.">Thank you</h4>
  <style>
    p.note {
        font-size: 0.80em;
        font-family: "Helvetica Neue", Arial, sans-serif; /* Helvetica on Mac aka sans-serif has broken U+2007 */
    }
</style>
  
  <p>
    This post summarizes the results of our 2018 user survey and draws comparisons between the results of our prior surveys from <a href="https://blog.golang.org/survey2016-results" target="_blank">2016</a> and <a href="https://blog.golang.org/survey2017-results" target="_blank">2017</a>.
  </p>
  

  
  <p>
    This year we had 5,883 survey respondents from 103 different countries. We are grateful to everyone who provided their feedback through this survey to help shape the future of Go. Thank you!
  </p>
  


    
      
  <h4 id="TOC_2.">Summary of findings</h4>
  
  <ul>
  
    <li>For the first time, <b>half of survey respondents are now using Go as part of their daily routine</b>. This year also saw significant increases in the number of respondents who develop in Go as part of their jobs and use Go outside of work responsibilities.</li>
  
    <li>The most <b>common uses for Go remain API/RPC services and CLI tools</b>. Automation tasks, while not as common as CLI tools and API services, are a fast-growing area for Go.</li>
  
    <li><b>Web development remains the most common domain</b> that survey respondents work in, but <b>DevOps showed the highest year-over-year growth</b> and is now the second most common domain.</li>
  
    <li>A large majority of survey respondents said <b>Go is their most-preferred programming language</b>, despite generally feeling less proficient with it than at least one other language.</li>
  
    <li><b>VS Code and GoLand are surging in popularity</b> and are now the most popular code editors among survey respondents.</li>
  
    <li>Highlighting the portable nature of Go, <b>many Go developers use more than one primary OS</b> for development. Linux and macOS are particularly popular, with a large majority of survey respondents using one or both of these operating systems to write Go code.</li>
  
    <li>Survey respondents appear to be <b>shifting away from on-prem Go deployments</b> and moving towards containers and serverless cloud deployments.</li>
  
    <li>The majority of respondents said they feel welcome in the Go community, and most ideas for improving the Go community specifically focus on <b>improving the experience of newcomers</b>.</li>
  
  </ul>

  
  <p>
    Read on for all of the details.
  </p>
  


    
      
  <h4 id="TOC_3.">Programming background</h4>
  
  
  <p>
    This year&#39;s results show a significant increase in the number of survey respondents who are paid to write Go as part of their jobs (68% → 72%), continuing a year-over-year trend that has been growing since our first survey in 2016. We also see an increase in the number of respondents who program in Go outside of work (64% → 70%). For the first time, the number of survey respondents who write in Go as part of their daily routine reached 50% (up from 44% in 2016). These findings suggests companies are continuing to embrace Go for professional software development at a consistent pace, and that Go&#39;s general popularity with developers remains strong.
  </p>
  

<div class="image">
  <img src="survey2018/fig1.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig2.svg" width="600">
</div>

  
  <p>
    To better understand where developers use Go, we broke responses down into three groups: 1) people who are using Go both in and outside of work, 2) people who use Go professionally but not outside of work, and 3) people who only write Go outside of their job responsibilities. Nearly half (46%) of respondents write Go code both professionally and on their own time (a 10-point increase since 2017), while the remaining respondents are closely split between either only writing Go at work, or only writing Go outside of work. The large percentage of respondents who both use Go at work and choose to use it outside of work suggests that the language appeals to developers who do not view software engineering as a day job: they also choose to hack on code outside of work responsibilities, and (as evidenced by 85% of respondents saying they&#39;d prefer Go for their next project, see section <i>Attitudes towards Go</i> below) Go is the top language they&#39;d prefer to use for these non-work-related projects.
  </p>
  

<div class="image">
  <img src="survey2018/fig4.svg" width="600">
</div>

  
  <p>
    When asked how long they&#39;ve been using Go, participants&#39; answers are strongly trending upward over time, with a higher percentage of responses in the 2-4 and 4+ year buckets each year. This is expected for a newer programming language, and we&#39;re glad to see that the percentage of respondents who are new to Go is dropping more slowly than the percentage of respondents who have been using Go for 2+ years is increasing, as this suggests that developers are not dropping out of the ecosystem after initially learning the language.
  </p>
  

<div class="image">
  <img src="survey2018/fig5.svg" width="600">
</div>

  
  <p>
    As in prior years, Go ranks at the top of respondents&#39; preferred languages and languages in which they have expertise. A majority of respondents (69%) claimed expertise in 5 different languages, highlighting that their attitudes towards Go are influenced by experiences with other programming stacks. The charts below are sorted by the number of respondents who ranked each language as their most preferred/understood (the darkest blue bars), which highlights three interesting bits: 
  </p>
  

  <ul>
  
    <li>While about ⅓ of respondents consider Go to be the language in which they have the most expertise, twice that many respondents consider it their most preferred programming language. So even though many respondents feel they haven&#39;t become as proficient with Go as with some other language, they still frequently prefer to develop with Go.</li>
  
    <li>Few survey respondents rank Rust as a language in which they have expertise (6.8%), yet 19% rank it as a top preferred language, indicating a high level of interest in Rust among this audience.</li>
  
    <li>Only three languages have more respondents who say they prefer the language than say they have expertise with it: Rust (2.41:1 ratio of preference:expertise), Kotlin (1.95:1), and Go (1.02:1). Higher preference than expertise implies interest—but little direct experience—in a language, while lower preference than expertise numbers suggests barriers to proficient use. Ratios near 1.0 suggest that most developers are able to work effectively <i>and</i> enjoyably with a given language. This data is corroborated by <a href="https://insights.stackoverflow.com/survey/2018/#most-loved-dreaded-and-wanted" target="_blank">Stack Overflow&#39;s 2018 developer survey</a>, which also found Rust, Kotlin, and Go to be among the most-preferred programming languages.</li>
  
  </ul>

<div class="image">
  <img src="survey2018/fig6.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig7.svg" width="600">
</div>
<p class="note">
    <i>Reading the data</i>: Participants could rank their top 5 languages. The color coding starts with dark blue for the top rank and lightens for each successive rank. These charts are sorted by the percentage of participants who ranked each language as their top choice.
</p>
    

    
      
  <h4 id="TOC_4.">Development domains</h4>
  
  
  <p>
    Survey respondents reported working on a median of three different domains, with a large majority (72%) working in 2-5 different areas. Web development is the most prevalent at 65%, and it increased its dominance as the primary area survey respondents work in (up from 61% last year): web development has been the most common domain for Go development since 2016. This year DevOps noticeably increased, from 36% to 41% of respondents, taking over the number two spot from Systems Programming. We did not find any domains with lower usage in 2018 than in 2017, suggesting that respondents are adopting Go for a wider variety of projects, rather than shifting usage from one domain to another.
  </p>
  

<div class="image">
  <img src="survey2018/fig8.svg" width="600">
</div>

  
  <p>
    Since 2016, the top two uses of Go have been writing API/RPC services and developing CLI applications. While CLI usage has remained stable at 63% for three years, API/RPC usage has increased from 60% in 2016 to 65% in 2017 to 73% today. These domains play to core strengths of Go and are both central to cloud-native software development, so we expect them to remain two of the primary scenarios for Go developers into the future. The percentage of respondents who write web services that directly return HTML has steadily dropped while API/RPC usage has increased, suggesting some migration to the API/RPC model for web services. Another year-over-year trend suggests that automation is also a growing area for Go, with 38% of respondents now using Go for scripts and automation tasks (up from 31% in 2016).
  </p>
  

<div class="image">
  <img src="survey2018/fig9.svg" width="600">
</div>

  
  <p>
    To better understand the contexts in which developers are using Go, we added a question about Go adoption across different industries. Perhaps unsurprisingly for a relatively new language, over half of survey respondents work in companies in the <i>Internet/web services</i> and <i>Software</i> categories (i.e., tech companies). The only other industries with &gt;3% responses were <i>Finance, banking, or insurance</i> and <i>Media, advertising, publishing, or entertainment</i>. (In the chart below, we&#39;ve condensed all of the categories with response rates below 3% into the &#34;Other&#34; category.) We&#39;ll continue tracking Go&#39;s adoption across industries to better understand developer needs outside of technology companies.
  </p>
  

<div class="image">
  <img src="survey2018/fig10.svg" width="600">
</div>


    
      
  <h4 id="TOC_5.">Attitudes towards Go</h4>
  
  
  <p>
    This year we added a question asking &#34;How likely are you to recommend Go to a friend or colleague?&#34; to calculate our <a href="https://en.wikipedia.org/wiki/Net_Promoter" target="_blank">Net Promoter Score</a>. This score attempts to measure how many more &#34;promoters&#34; a product has than &#34;detractors&#34; and ranges from -100 to 100; a positive value suggests most people are likely to recommend using a product, while negative values suggest most people are likely to recommend against using it. Our 2018 score is 61 (68% promoters - 7% detractors) and will serve as a baseline to help us gauge community sentiment towards the Go ecosystem over time.
  </p>
  

<div class="image">
  <img src="survey2018/fig11.svg" width="600">
</div>

  
  <p>
    In addition to NPS, we asked several questions about developer satisfaction with Go. Overall, survey respondents indicated a high level of satisfaction, consistent with prior years. Large majorities say they are happy with Go (89%), would prefer to use Go for their next project (85%), and feel that it is working well for their team (66%), while a plurality feel that Go is at least somewhat critical to their company&#39;s success (44%). While all of these metrics showed an increase in 2017, they remained mostly stable this year. (The wording of the first question changed in 2018 from &#34;<i>I would recommend using Go to others</i>&#34; to &#34;<i>Overall, I&#39;m happy with Go</i>&#34;, so those results are not directly comparable.) 
  </p>
  

<div class="image">
  <img src="survey2018/fig12.svg" width="600">
</div>

  
  <p>
    Given the strong sentiment towards preferring Go for future development, we want to understand what prevents developers from doing so. These remained largely unchanged since last year: about ½ of survey respondents work on existing projects written in other languages, and ⅓ work on a team or project that prefers to use a different language. Missing language features and libraries round out the most common reasons respondents did not use Go more. We also asked about the biggest challenges developers face while using Go; unlike most of our survey questions, respondents could type in anything they wished to answer this question. We analyzed the results via machine learning to identify common themes and counting the number of responses that supported each theme. The top three major challenges we identified are:
  </p>
  

  <ul>
  
    <li>Package management (e.g., &#34;Keeping up with vendoring&#34;, &#34;dependency / packet [sic] management / vendoring not unified&#34;)</li>
  
    <li>Differences from more familiar programming languages (e.g., &#34;syntax close to C-languages with slightly different semantics makes me look up references somewhat more than I&#39;d like&#34;, &#34;coworkers who come from non-Go backgrounds trying to use Go as a version of their previous language but with channels and Goroutines&#34;)</li>
  
    <li>Lack of generics (e.g., &#34;Lack of generics makes it difficult to persuade people who have not tried Go that they would find it efficient.&#34;, &#34;Hard to build richer abstractions (want generics)&#34;)</li>
  
  </ul>

<div class="image">
  <img src="survey2018/fig13.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig14.svg" width="600">
</div>

  
  <p>
    This year we added several questions about developer satisfaction with different aspects of Go. Survey respondents were very satisfied with Go applications&#39; CPU performance (46:1, meaning 46 respondents said they were satisfied for every 1 respondent who said they were not satisfied), build speed (37:1), and application memory utilization (32:1). Responses for application debuggability (3.2:1)  and binary size (6.4:1), however, suggest room for improvement.
  </p>
  

  
  <p>
    The dissatisfaction with binary size largely comes from developers building CLIs, only 30% of whom are satisfied with the size of Go&#39;s generated binaries. For all other types of applications, however, developer satisfaction was &gt; 50%, and binary size was consistently ranked at the bottom of the list of important factors.
  </p>
  

  
  <p>
    Debuggability, conversely, stands out when we look at how respondents ranked the importance of each aspect; 44% of respondents ranked debuggability as their most or second-most important aspect, but only 36% were satisfied with the current state of Go debugging. Debuggability was consistently rated about as important as memory usage and build speed but with significantly lower satisfaction levels, and this pattern held true regardless of the type of software respondents were building. The two most recent Go releases, Go 1.11 and 1.12, both contained significant improvements to debuggability. We plan to investigate how developers debug Go applications in more depth this year, with a goal of improving the overall debugging experience for Go developers.
  </p>
  

<div class="image">
  <img src="survey2018/fig15.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig29.svg" width="600">
</div>


    
      
  <h4 id="TOC_6.">Development environments</h4>
  
  
  <p>
    We asked respondents which operating systems they primarily use when writing Go code. A majority (65%) of respondents said they use Linux, 50% use macOS, and 18% use Windows, consistent with last year. This year we also looked at how many respondents develop on multiple OSes vs. a single OS. Linux and macOS remain the clear leaders, with 81% of respondents developing on some mix of these two systems. Only 3% of respondents evenly split their time between all three OSes. Overall, 41% of respondents use multiple operating systems for Go development, highlighting the cross-platform nature of Go.
  </p>
  

<div class="image">
  <img src="survey2018/fig16.svg" width="600">
</div>

  
  <p>
    Last year, VS Code edged out Vim as the most popular Go editor among survey respondents. This year it significantly expanded its lead to become the preferred editor for over ⅓ of our survey respondents (up from 27% last year). GoLand also experienced strong growth and is now the second most-preferred editor at 22%, swapping places with Vim (down to 17%). The surging popularity of VS Code and GoLand appear to be coming at the expense of Sublime Text and Atom. Vim also saw the number of respondents ranking it their top choice drop, but it remains the most popular second-choice editor at 14%. Interestingly, we found no differences in the level of satisfaction respondents reported for their editor(s) of choice.
  </p>
  

  
  <p>
    We also asked respondents what would most improve Go support in their preferred editor. Like the &#34;biggest challenge&#34; question above, participants could write in their own response rather than select from a multiple-choice list. A thematic analysis on the responses revealed that <i>improved debugging support</i> (e.g., &#34;Live debugging&#34;, &#34;Integrated debugging&#34;, &#34;Even better debugging&#34;) was the most-common request, followed by <i>improved code completion</i> (e.g., &#34;autocomplete performance and quality&#34;, &#34;smarter autocomplete&#34;). Other requests include better integration with Go&#39;s CLI toolchain, better support for modules/packages, and general performance improvements.
  </p>
  

<div class="image">
  <img src="survey2018/fig17.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig18.svg" width="600">
</div>

  
  <p>
    This year we also added a question asking which deployment architectures are most important to Go developers. Unsurprisingly, survey respondents overwhelmingly view x86/x86-64 as their top deployment platform (76% of respondents listed it as their most important deployment architecture, and 84% had it in their top 3). The ranking of the second- and third-choice architectures, however, is informative: there is significant interest in ARM64 (45%), WebAssembly (30%), and ARM (22%), but very little interest in other platforms.
  </p>
  

<div class="image">
  <img src="survey2018/fig19.svg" width="600">
</div>


    
      
  <h4 id="TOC_7.">Deployments and services</h4>
  
  
  <p>
    For 2018 we see a continuation of the trend from on-prem to cloud hosting for both Go and non-Go deployments. The percentage of survey respondents who deploy Go applications to on-prem servers dropped from 43% → 32%, mirroring the 46% → 36% drop reported for non-Go deployments. The cloud services which saw the highest year-over-year growth include AWS Lambda (4% → 11% for Go, 10% → 15% non-Go) and Google Kubernetes Engine (8% → 12% for Go, 5% → 10% non-Go), suggesting that serverless and containers are becoming increasingly popular deployment platforms. This service growth appears to be driven by respondents who had already adopted cloud services, however, as we found no meaningful growth in the percentage of respondents who deploy to at least one cloud service this year (55% → 56%). We also see steady growth in Go deployments to GCP since 2016, increasing from 12% → 19% of respondents.
  </p>
  

<div class="image">
  <img src="survey2018/fig20.svg" width="600">
</div>

  
  <p>
    Perhaps correlated with the decrease in on-prem deployments, this year we saw cloud storage become the second-most used service by survey respondents, increasing from 32% → 44%. Authentication &amp; federation services also saw a significant increase (26% → 33%). The primary service survey respondents access from Go remains open-source relational databases, which ticked up from 61% → 65% of respondents. As the below chart shows, service usage increased across the board.
  </p>
  

<div class="image">
  <img src="survey2018/fig21.svg" width="600">
</div>


    
      
  <h4 id="TOC_8.">Go community</h4>
  
  
  <p>
    The top community sources for finding answers to Go questions continue to be Stack Overflow (23% of respondents marked it as their top source), Go web sites (18% for godoc.org, 14% for golang.org), and reading source code (8% for source code generally, 4% for GitHub specifically). The order remains largely consistent with prior years. The primary sources for Go news remain the Go blog, Reddit&#39;s r/golang, Twitter, and Hacker News. These were also the primary distribution methods for this survey, however, so there is likely some bias in this result. In the two charts below, we&#39;ve grouped sources used by less than &lt; 5% of respondents into the &#34;Other&#34; category.
  </p>
  

<div class="image">
  <img src="survey2018/fig24.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig25.svg" width="600">
</div>

  
  <p>
    This year, 55% of survey respondents said they have or are interested in contributing to the Go community, slightly down from 59% last year. Because the two most common areas for contribution (the standard library and official Go tools) require interacting with the core Go team, we suspect this decrease may be related to a dip in the percentage of participants who agreed with the statements &#34;I feel comfortable approaching the Go project leadership with questions and feedback&#34; (30% → 25%) and &#34;I am confident in the leadership of Go (54% → 46%).
  </p>
  

<div class="image">
  <img src="survey2018/fig26.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig27.svg" width="600">
</div>

  
  <p>
    An important aspect of community is helping everyone feel welcome, especially people from traditionally under-represented demographics. To better understand this, we asked an optional question about identification across several under-represented groups. In 2017 we saw year-over-year increases across the board. For 2018, we saw a similar percentage of respondents (12%) identify as part of an under-represented group, and this was paired with a significant decrease in the percentage of respondents who do <b>not</b> identify as part of an under-represented group. In 2017, for every person who identified as part of an under-represented group, 3.5 people identified as not part of an under-represented group (3.5:1 ratio). In 2018 that ratio improved to 3.08:1. This suggests that the Go community is at least retaining the same proportions of under-represented members, and may even be increasing.
  </p>
  

<div class="image">
  <img src="survey2018/fig28.svg" width="600">
</div>

  
  <p>
    Maintaining a healthy community is extremely important to the Go project, so for the past three years we&#39;ve been measuring the extent to which developers feel welcome in the Go community. This year we saw a drop in the percentage of survey respondents who agree with the statement &#34;I feel welcome in the Go community&#34;, from 66% → 59%.
  </p>
  

  
  <p>
    To better understand this decrease, we looked more closely at who reported feeling less welcome. Among traditionally under-represented groups, fewer people reported feeling unwelcome in 2018, suggesting that outreach in that area has been helpful. Instead, we found a linear relationship between the length of time someone has used Go and how welcome they feel: newer Go developers felt significantly less welcome (at 50%) than developers with 1-2 years of experience (62%), who in turn felt less welcome than developers with a few years of experience (73%). This interpretation of the data is supported by responses to the question &#34;What changes would make the Go community more welcoming?&#34;. Respondents&#39; comments can be broadly grouped into four categories:
  </p>
  

  <ul>
  
    <li>Reduce a perception of elitism, especially for newcomers to Go (e.g., &#34;less dismissiveness&#34;, &#34;Less defensiveness and hubris&#34;)</li>
  
    <li>Increase transparency at the leadership level (e.g., &#34;Future direction and planning discussions&#34;, &#34;Less top down leadership&#34;, &#34;More democratic&#34;)</li>
  
    <li>Increase introductory resources (e.g., &#34;A more clear introduction for contributors&#34;, &#34;Fun challenges to learn best practices&#34;)</li>
  
    <li>More events and meetups, with a focus on covering a larger geographic area (e.g., &#34;More meetups &amp; social events&#34;, &#34;Events in more cities&#34;)</li>
  
  </ul>

  
  <p>
    This feedback is very helpful and gives us concrete areas we can focus on to improve the experience of being a Go developer. While it doesn&#39;t represent a large percentage of our user base, we take this feedback very seriously and are working on improving each area.
  </p>
  

<div class="image">
  <img src="survey2018/fig22.svg" width="600">
</div>

<div class="image">
  <img src="survey2018/fig23.svg" width="600">
</div>


    
      
  <h4 id="TOC_9.">Conclusion</h4>
  
  
  <p>
    We hope you&#39;ve enjoyed seeing the results of our 2018 developer survey. These results are impacting our 2019 planning, and in the coming months we&#39;ll share some ideas with you to address specific issues and needs the community has highlighted for us. Once again, thank you to everyone who contributed to this survey!
  </p>
  


    
  


		
			<p class="author">By Todd Kulesza, Steve Francia</p>
		
	</div>

	
		
	<div class="article" data-slug="/debugging-what-you-deploy">
		<h3 class="title"><a href="/debugging-what-you-deploy">Debugging what you deploy in Go 1.12</a></h3>
		<p class="date">21 March 2019</p>
		

  
  
    
      
  <h4 id="TOC_1.">Introduction</h4>
  
  
  <p>
    Go 1.11 and Go 1.12 make significant progress toward allowing developers to debug the same optimized binaries that they deploy to production.
  </p>
  

  
  <p>
    As the Go compiler has become increasingly aggressive in producing faster binaries, we&#39;ve lost ground in debuggability. In Go 1.10, users needed to disable optimizations entirely in order to have a good debugging experience from interactive tools like Delve. But users shouldn’t have to trade performance for debuggability, especially when running production services. If your problem is occurring in production, you need to debug it in production, and that shouldn’t require deploying unoptimized binaries.
  </p>
  

  
  <p>
    For Go 1.11 and 1.12, we focused on improving the debugging experience on optimized binaries (the default setting of the Go compiler). Improvements include
  </p>
  

  <ul>
  
    <li>More accurate value inspection, in particular for arguments at function entry;</li>
  
    <li>More precisely identifying statement boundaries so that stepping is less jumpy and breakpoints more often land where the programmer expects;</li>
  
    <li>And preliminary support for Delve to call Go functions (goroutines and garbage collection make this trickier than it is in C and C++).</li>
  
  </ul>


    
      
  <h4 id="TOC_2.">Debugging optimized code with Delve</h4>
  
  
  <p>
    <a href="https://github.com/go-delve/delve" target="_blank">Delve</a> is a debugger for Go on x86 supporting both Linux and macOS. Delve is aware of goroutines and other Go features and provides one of the best Go debugging experiences. Delve is also the debugging engine behind <a href="https://www.jetbrains.com/go/" target="_blank">GoLand</a>, <a href="https://code.visualstudio.com/" target="_blank">VS Code</a>, and <a href="https://github.com/fatih/vim-go" target="_blank">Vim</a>.
  </p>
  

  
  <p>
    Delve normally rebuilds the code it is debugging with <code>-gcflags &#34;all=-N -l&#34;</code>, which disables inlining and most optimizations.  To debug optimized code with delve, first build the optimized binary, then use <code>dlv exec your_program</code> to debug it.  Or, if you have a core file from a crash, you can examine it with <code>dlv core your_program your_core</code>. With 1.12 and the latest Delve releases, you should be able to examine many variables, even in optimized binaries.
  </p>
  


    
      
  <h4 id="TOC_3.">Improved value inspection</h4>
  
  
  <p>
    When debugging optimized binaries produced by Go 1.10, variable values were usually completely unavailable. In contrast, starting with Go 1.11, variables can usually be examined even in optimized binaries, unless they’ve been optimized away completely. In Go 1.11 the compiler began emitting DWARF location lists so debuggers can track variables as they move in and out of registers and reconstruct complex objects that are split across different registers and stack slots.
  </p>
  


    
      
  <h4 id="TOC_4.">Improved stepping</h4>
  
  
  <p>
    This shows an example of stepping through a simple function in a debugger in 1.10, with flaws (skipped and repeated lines) highlighted by red arrows.
  </p>
  

<div class="image">
  <img src="debugging-what-you-deploy.svg" width="450">
</div>

  
  <p>
    Flaws like this make it easy to lose track of where you are when stepping through a program and interfere with hitting breakpoints.
  </p>
  

  
  <p>
    Go 1.11 and 1.12 record statement boundary information and do a better job of tracking source line numbers through optimizations and inlining. As a result, in Go 1.12, stepping through this code stops on every line and does so in the order you would expect.
  </p>
  


    
      
  <h4 id="TOC_5.">Function calls</h4>
  
  
  <p>
    Function call support in Delve is still under development, but simple cases work.  For example:
  </p>
  

  
  <div class="code"><pre>(dlv) call fib(6)
&gt; main.main() ./hello.go:15 (PC: 0x49d648)
Values returned:
    ~r1: 8</pre></div>
  


    
      
  <h4 id="TOC_6.">The path forward</h4>
  
  
  <p>
    Go 1.12 is a step toward a better debugging experience for optimized binaries and we have plans to improve it even further.
  </p>
  

  
  <p>
    There are fundamental tradeoffs between debuggability and performance, so we’re focusing on the highest-priority debugging defects, and working to collect automated metrics to monitor our progress and catch regressions.
  </p>
  

  
  <p>
    We’re focusing on generating correct information for debuggers about variable locations, so if a variable can be printed, it is printed correctly. We’re also looking at making variable values available more of the time, particularly at key points like call sites, though in many cases improving this would require slowing down program execution. Finally, we’re working on improving stepping: we’re focusing on the order of stepping with panics, the order of stepping around loops, and generally trying to follow source order where possible.
  </p>
  


    
      
  <h4 id="TOC_7.">A note on macOS support</h4>
  
  
  <p>
    Go 1.11 started compressing debug information to reduce binary sizes. This is natively supported by Delve, but neither LLDB nor GDB support compressed debug info on macOS. If you are using LLDB or GDB, there are two workarounds: build binaries with <code>-ldflags=-compressdwarf=false</code>, or use <a href="https://godoc.org/golang.org/x/tools/cmd/splitdwarf" target="_blank">splitdwarf</a> (<code>go get golang.org/x/tools/cmd/splitdwarf</code>) to decompress the debug information in an existing binary.
  </p>
  


    
  


		
			<p class="author">By David Chase</p>
		
	</div>

	
		
	<div class="article" data-slug="/using-go-modules">
		<h3 class="title"><a href="/using-go-modules">Using Go Modules</a></h3>
		<p class="date">19 March 2019</p>
		

  
  
    
      
  <h4 id="TOC_1.">Introduction</h4>
  
  
  <p>
    Go 1.11 and 1.12 include preliminary


    <a href="https://golang.org/doc/go1.11#modules" target="_blank">support for modules</a>,


    Go’s


    <a href="https://blog.golang.org/versioning-proposal" target="_blank">new dependency management system</a>


    that makes dependency version information explicit


    and easier to manage.


    This blog post is an introduction to the basic operations needed


    to get started using modules.


    A followup post will cover releasing modules for others to use.
  </p>
  

  
  <p>
    A module is a collection of


    <a href="https://golang.org/ref/spec#Packages" target="_blank">Go packages</a>


    stored in a file tree with a <code>go.mod</code> file at its root.


    The <code>go.mod</code> file defines the module’s <i>module path</i>,


    which is also the import path used for the root directory,


    and its <i>dependency requirements</i>,


    which are the other modules needed for a successful build.


    Each dependency requirement is


    written as a module path and a specific


    <a href="http://semver.org/" target="_blank">semantic version</a>.
  </p>
  

  
  <p>
    As of Go 1.11, the go command enables the use of modules


    when the current directory or any parent directory has a <code>go.mod</code>,


    provided the directory is <i>outside</i> <code>$GOPATH/src</code>.


    (Inside <code>$GOPATH/src</code>, for compatibility, the go command


    still runs in the old GOPATH mode, even if a <code>go.mod</code> is found.


    See the


    <a href="https://golang.org/cmd/go/#hdr-Preliminary_module_support" target="_blank">go command documentation</a>


    for details.)


    Starting in Go 1.13, module mode will be the default for all development.
  </p>
  

  
  <p>
    This post walks through a sequence of common operations


    that arise when developing Go code with modules:
  </p>
  

  <ul>
  
    <li>Creating a new module.</li>
  
    <li>Adding a dependency.</li>
  
    <li>Upgrading dependencies.</li>
  
    <li>Adding a dependency on a new major version.</li>
  
    <li>Upgrading a dependency to a new major version.</li>
  
    <li>Removing unused dependencies.</li>
  
  </ul>


    
      
  <h4 id="TOC_2.">Creating a new module</h4>
  
  
  <p>
    Let&#39;s create a new module.
  </p>
  

  
  <p>
    Create a new, empty directory somewhere outside <code>$GOPATH/src</code>,


    <code>cd</code> into that directory, and then create a new source file, <code>hello.go</code>:
  </p>
  

  
  <div class="code"><pre>package hello

func Hello() string {
    return &#34;Hello, world.&#34;
}</pre></div>
  

  
  <p>
    Let&#39;s write a test, too, in <code>hello_test.go</code>:
  </p>
  

  
  <div class="code"><pre>package hello

import &#34;testing&#34;

func TestHello(t *testing.T) {
    want := &#34;Hello, world.&#34;
    if got := Hello(); got != want {
        t.Errorf(&#34;Hello() = %q, want %q&#34;, got, want)
    }
}</pre></div>
  

  
  <p>
    At this point, the directory contains a package, but not a module,


    because there is no <code>go.mod</code> file.


    If we were working in <code>/home/gopher/hello</code> and ran <code>go test</code> now,


    we&#39;d see:
  </p>
  

  
  <div class="code"><pre>$ go test
PASS
ok      _/home/gopher/hello    0.020s
$</pre></div>
  

  
  <p>
    The last line summarizes the overall package test.


    Because we are working outside <code>$GOPATH</code>


    and also outside any module,


    the <code>go</code> command knows no import path for


    the current directory and makes up a fake one based


    on the directory name: <code>_/home/gopher/hello</code>.
  </p>
  

  
  <p>
    Let&#39;s make the current directory the root of a module


    by using <code>go mod init</code> and then try <code>go test</code> again:
  </p>
  

  
  <div class="code"><pre>$ go mod init example.com/hello
go: creating new go.mod: module example.com/hello
$ go test
PASS
ok      example.com/hello    0.020s
$</pre></div>
  

  
  <p>
    Congratulations! You’ve written and tested your first module.
  </p>
  

  
  <p>
    The <code>go mod init</code> command wrote a <code>go.mod</code> file:
  </p>
  

  
  <div class="code"><pre>$ cat go.mod
module example.com/hello

go 1.12
$</pre></div>
  

  
  <p>
    The <code>go.mod</code> file only appears in the root of the module.


    Packages in subdirectories have import paths consisting of


    the module path plus the path to the subdirectory.


    For example, if we created a subdirectory <code>world</code>,


    we would not need to (nor want to) run <code>go mod init</code> there.


    The package would automatically be recognized as part of the


    <code>example.com/hello</code> module, with import path


    <code>example.com/hello/world</code>.
  </p>
  


    
      
  <h4 id="TOC_3.">Adding a dependency</h4>
  
  
  <p>
    The primary motivation for Go modules was to improve the


    experience of using (that is, adding a dependency on)


    code written by other developers.
  </p>
  

  
  <p>
    Let&#39;s update our <code>hello.go</code> to import <code>rsc.io/quote</code>


    and use it to implement <code>Hello</code>:
  </p>
  

  
  <div class="code"><pre>package hello

import &#34;rsc.io/quote&#34;

func Hello() string {
    return quote.Hello()
}</pre></div>
  

  
  <p>
    Now let’s run the test again:
  </p>
  

  
  <div class="code"><pre>$ go test
go: finding rsc.io/quote v1.5.2
go: downloading rsc.io/quote v1.5.2
go: extracting rsc.io/quote v1.5.2
go: finding rsc.io/sampler v1.3.0
go: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
go: downloading rsc.io/sampler v1.3.0
go: extracting rsc.io/sampler v1.3.0
go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
go: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
PASS
ok      example.com/hello    0.023s
$</pre></div>
  

  
  <p>
    The <code>go</code> command resolves imports by using the specific


    dependency module versions listed in <code>go.mod</code>.


    When it encounters an <code>import</code> of a package not provided


    by any module in <code>go.mod</code>, the <code>go</code> command automatically


    looks up the module containing that package and adds it to


    <code>go.mod</code>, using the latest version.


    (“Latest” is defined as the


    latest tagged stable (non-<a href="https://semver.org/#spec-item-9" target="_blank">prerelease</a>) version,


    or else the latest tagged prerelease version,


    or else the latest untagged version.)


    In our example, <code>go test</code> resolved the new import <code>rsc.io/quote</code>


    to the module <code>rsc.io/quote v1.5.2</code>.


    It also downloaded two dependencies used by <code>rsc.io/quote</code>,


    namely <code>rsc.io/sampler</code> and <code>golang.org/x/text</code>.


    Only direct dependencies are recorded in the <code>go.mod</code> file:
  </p>
  

  
  <div class="code"><pre>$ cat go.mod
module example.com/hello

go 1.12

require rsc.io/quote v1.5.2
$</pre></div>
  

  
  <p>
    A second <code>go test</code> command will not repeat this work,


    since the <code>go.mod</code> is now up-to-date and the downloaded


    modules are cached locally (in <code>$GOPATH/pkg/mod</code>):
  </p>
  

  
  <div class="code"><pre>$ go test
PASS
ok      example.com/hello    0.020s
$</pre></div>
  

  
  <p>
    Note that while the <code>go</code> command makes adding a new dependency


    quick and easy, it is not without cost.


    Your module now literally <i>depends</i> on the new dependency


    in critical areas such as correctness, security, and proper licensing,


    just to name a few.


    For more considerations, see Russ Cox&#39;s blog post,


    “<a href="https://research.swtch.com/deps" target="_blank">Our Software Dependency Problem</a>.”
  </p>
  

  
  <p>
    As we saw above, adding one direct dependency often


    brings in other indirect dependencies too.


    The command <code>go list -m all</code> lists the current module


    and all its dependencies:
  </p>
  

  
  <div class="code"><pre>$ go list -m all
example.com/hello
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
rsc.io/quote v1.5.2
rsc.io/sampler v1.3.0
$</pre></div>
  

  
  <p>
    In the <code>go list</code> output, the current module,


    also known as the <i>main module</i>,


    is always the first line,


    followed by dependencies sorted by module path.
  </p>
  

  
  <p>
    The <code>golang.org/x/text</code> version <code>v0.0.0-20170915032832-14c0d48ead0c</code>


    is an example of a


    <a href="https://golang.org/cmd/go/#hdr-Pseudo_versions" target="_blank">pseudo-version</a>,


    which is the <code>go</code> command&#39;s version syntax


    for a specific untagged commit.
  </p>
  

  
  <p>
    In addition to <code>go.mod</code>, the <code>go</code> command


    maintains a file named <code>go.sum</code> containing


    the expected <a href="https://golang.org/cmd/go/#hdr-Module_downloading_and_verification" target="_blank">cryptographic hashes</a> of the content of specific module versions:
  </p>
  

  
  <div class="code"><pre>$ cat go.sum
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO...
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq...
rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO&#43;QwRjYZOKnaM9Uh2b40tElTs3...
rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX...
rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD&#43;gZwtXXI&#43;RODJ2Wc4O7MPEh/Q...
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9...
$</pre></div>
  

  
  <p>
    The <code>go</code> command uses the <code>go.sum</code> file to ensure that


    future downloads of these modules retrieve the same bits


    as the first download,


    to ensure the modules your project depends on


    do not change unexpectedly,


    whether for malicious, accidental, or other reasons.


    Both <code>go.mod</code> and <code>go.sum</code> should be checked into version control.
  </p>
  


    
      
  <h4 id="TOC_4.">Upgrading dependencies</h4>
  
  
  <p>
    With Go modules, versions are referenced with semantic version tags.


    A semantic version has three parts: major, minor, and patch.


    For example, for <code>v0.1.2</code>, the major version is 0, the minor version is 1,


    and the patch version is 2.


    Let&#39;s walk through a couple minor version upgrades.


    In the next section, we’ll consider a major version upgrade.
  </p>
  

  
  <p>
    From the output of <code>go list -m all</code>,


    we can see we&#39;re using an untagged version of <code>golang.org/x/text</code>.


    Let&#39;s upgrade to the latest tagged version and test that everything still works:
  </p>
  

  
  <div class="code"><pre>$ go get golang.org/x/text
go: finding golang.org/x/text v0.3.0
go: downloading golang.org/x/text v0.3.0
go: extracting golang.org/x/text v0.3.0
$ go test
PASS
ok      example.com/hello    0.013s
$</pre></div>
  

  
  <p>
    Woohoo! Everything passes.


    Let&#39;s take another look at <code>go list -m all</code> and the <code>go.mod</code> file:
  </p>
  

  
  <div class="code"><pre>$ go list -m all
example.com/hello
golang.org/x/text v0.3.0
rsc.io/quote v1.5.2
rsc.io/sampler v1.3.0
$ cat go.mod
module example.com/hello

go 1.12

require (
    golang.org/x/text v0.3.0 // indirect
    rsc.io/quote v1.5.2
)
$</pre></div>
  

  
  <p>
    The <code>golang.org/x/text</code> package has been upgraded to the latest tagged version (<code>v0.3.0</code>).


    The <code>go.mod</code> file has been updated to specify <code>v0.3.0</code> too.


    The <code>indirect</code> comment indicates a dependency is not used directly


    by this module, only indirectly by other module dependencies.


    See <code>go help modules</code> for details.
  </p>
  

  
  <p>
    Now let&#39;s try upgrading the <code>rsc.io/sampler</code> minor version.


    Start the same way, by running <code>go get</code> and running tests:
  </p>
  

  
  <div class="code"><pre>$ go get rsc.io/sampler
go: finding rsc.io/sampler v1.99.99
go: downloading rsc.io/sampler v1.99.99
go: extracting rsc.io/sampler v1.99.99
$ go test
--- FAIL: TestHello (0.00s)
    hello_test.go:8: Hello() = &#34;99 bottles of beer on the wall, 99 bottles of beer, ...&#34;, want &#34;Hello, world.&#34;
FAIL
exit status 1
FAIL    example.com/hello    0.014s
$</pre></div>
  

  
  <p>
    Uh, oh! The test failure shows that the


    latest version of <code>rsc.io/sampler</code> is incompatible with our usage.


    Let&#39;s list the available tagged versions of that module:
  </p>
  

  
  <div class="code"><pre>$ go list -m -versions rsc.io/sampler
rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99
$</pre></div>
  

  
  <p>
    We had been using v1.3.0; v1.99.99 is clearly no good.


    Maybe we can try using v1.3.1 instead:
  </p>
  

  
  <div class="code"><pre>$ go get rsc.io/sampler@v1.3.1
go: finding rsc.io/sampler v1.3.1
go: downloading rsc.io/sampler v1.3.1
go: extracting rsc.io/sampler v1.3.1
$ go test
PASS
ok      example.com/hello    0.022s
$</pre></div>
  

  
  <p>
    Note the explicit <code>@v1.3.1</code> in the <code>go get</code> argument.


    In general each argument passed to <code>go get</code> can take


    an explicit version; the default is <code>@latest</code>,


    which resolves to the latest version as defined earlier.
  </p>
  


    
      
  <h4 id="TOC_5.">Adding a dependency on a new major version</h4>
  
  
  <p>
    Let&#39;s add a new function to our package:


    <code>func Proverb</code> returns a Go concurrency proverb,


    by calling <code>quote.Concurrency</code>, which is provided by


    the module <code>rsc.io/quote/v3</code>.


    First we update <code>hello.go</code> to add the new function:
  </p>
  

  
  <div class="code"><pre>package hello

import (
    &#34;rsc.io/quote&#34;
    quoteV3 &#34;rsc.io/quote/v3&#34;
)

func Hello() string {
    return quote.Hello()
}

func Proverb() string {
    return quoteV3.Concurrency()
}</pre></div>
  

  
  <p>
    Then we add a test to <code>hello_test.go</code>:
  </p>
  

  
  <div class="code"><pre>func TestProverb(t *testing.T) {
    want := &#34;Concurrency is not parallelism.&#34;
    if got := Proverb(); got != want {
        t.Errorf(&#34;Proverb() = %q, want %q&#34;, got, want)
    }
}</pre></div>
  

  
  <p>
    Then we can test our code:
  </p>
  

  
  <div class="code"><pre>$ go test
go: finding rsc.io/quote/v3 v3.1.0
go: downloading rsc.io/quote/v3 v3.1.0
go: extracting rsc.io/quote/v3 v3.1.0
PASS
ok      example.com/hello    0.024s
$</pre></div>
  

  
  <p>
    Note that our module now depends on both <code>rsc.io/quote</code> and <code>rsc.io/quote/v3</code>:
  </p>
  

  
  <div class="code"><pre>$ go list -m rsc.io/q...
rsc.io/quote v1.5.2
rsc.io/quote/v3 v3.1.0
$</pre></div>
  

  
  <p>
    Each different major version (<code>v1</code>, <code>v2</code>, and so on) of a Go module


    uses a different module path: starting at <code>v2</code>, the path must end in the major version.


    In the example, <code>v3</code> of <code>rsc.io/quote</code> is no longer <code>rsc.io/quote</code>: instead,


    it is identified by the module path <code>rsc.io/quote/v3</code>.


    This convention is called


    <a href="https://research.swtch.com/vgo-import" target="_blank">semantic import versioning</a>,


    and it gives incompatible packages (those with different major versions)


    different names.


    In contrast, <code>v1.6.0</code> of <code>rsc.io/quote</code> should be backwards-compatible


    with <code>v1.5.2</code>, so it reuses the name <code>rsc.io/quote</code>.


    (In the previous section, <code>rsc.io/sampler</code> <code>v1.99.99</code>


    <i>should</i> have been backwards-compatible


    with <code>rsc.io/sampler</code> <code>v1.3.0</code>, but bugs or incorrect client assumptions about


    module behavior can both happen.)
  </p>
  

  
  <p>
    The <code>go</code> command allows a build to include at most one version of


    any particular module path, meaning at most one of each major


    version: one <code>rsc.io/quote</code>, one <code>rsc.io/quote/v2</code>, one <code>rsc.io/quote/v3</code>,


    and so on.


    This gives module authors a clear rule about possible duplication


    of a single module path: it is impossible for a program to build with both


    <code>rsc.io/quote v1.5.2</code> and <code>rsc.io/quote v1.6.0</code>.


    At the same time, allowing different major versions of a module


    (because they have different paths)


    gives module consumers the ability to


    upgrade to a new major version incrementally.


    In this example, we wanted to use <code>quote.Concurrency</code> from <code>rsc/quote/v3 v3.1.0</code>


    but are not yet ready to migrate our uses of <code>rsc.io/quote v1.5.2</code>.


    The ability to migrate incrementally


    is especially important in a large program or codebase.
  </p>
  


    
      
  <h4 id="TOC_6.">Upgrading a dependency to a new major version</h4>
  
  
  <p>
    Let&#39;s complete our conversion from using <code>rsc.io/quote</code> to using only <code>rsc.io/quote/v3</code>.


    Because of the major version change, we should expect that some APIs may have


    been removed, renamed, or otherwise changed in incompatible ways.


    Reading the docs, we can see that <code>Hello</code> has become <code>HelloV3</code>:
  </p>
  

  
  <div class="code"><pre>$ go doc rsc.io/quote/v3
package quote // import &#34;rsc.io/quote&#34;

Package quote collects pithy sayings.

func Concurrency() string
func GlassV3() string
func GoV3() string
func HelloV3() string
func OptV3() string
$</pre></div>
  

  
  <p>
    (There is also a


    <a href="https://golang.org/issue/30778" target="_blank">known bug</a> in the output;


    the displayed import path has incorrectly dropped the <code>/v3</code>.)
  </p>
  

  
  <p>
    We can update our use of <code>quote.Hello()</code> in <code>hello.go</code> to use <code>quoteV3.HelloV3()</code>:
  </p>
  

  
  <div class="code"><pre>package hello

import quoteV3 &#34;rsc.io/quote/v3&#34;

func Hello() string {
    return quoteV3.HelloV3()
}

func Proverb() string {
    return quoteV3.Concurrency()
}</pre></div>
  

  
  <p>
    And then at this point, there&#39;s no need for the renamed import anymore,


    so we can undo that:
  </p>
  

  
  <div class="code"><pre>package hello

import &#34;rsc.io/quote/v3&#34;

func Hello() string {
    return quote.HelloV3()
}

func Proverb() string {
    return quote.Concurrency()
}</pre></div>
  

  
  <p>
    Let&#39;s re-run the tests to make sure everything is working:
  </p>
  

  
  <div class="code"><pre>$ go test
PASS
ok      example.com/hello       0.014s</pre></div>
  


    
      
  <h4 id="TOC_7.">Removing unused dependencies</h4>
  
  
  <p>
    We&#39;ve removed all our uses of <code>rsc.io/quote</code>,


    but it still shows up in <code>go list -m all</code> and in our <code>go.mod</code> file:
  </p>
  

  
  <div class="code"><pre>$ go list -m all
example.com/hello
golang.org/x/text v0.3.0
rsc.io/quote v1.5.2
rsc.io/quote/v3 v3.1.0
rsc.io/sampler v1.3.1
$ cat go.mod
module example.com/hello

go 1.12

require (
    golang.org/x/text v0.3.0 // indirect
    rsc.io/quote v1.5.2
    rsc.io/quote/v3 v3.0.0
    rsc.io/sampler v1.3.1 // indirect
)
$</pre></div>
  

  
  <p>
    Why? Because building a single package, like with <code>go build</code> or <code>go test</code>,


    can easily tell when something is missing and needs to be added,


    but not when something can safely be removed.


    Removing a dependency can only be done after


    checking all packages in a module,


    and all possible build tag combinations for those packages.


    An ordinary build command does not load this information,


    and so it cannot safely remove dependencies.
  </p>
  

  
  <p>
    The <code>go mod tidy</code> command cleans up these unused dependencies:
  </p>
  

  
  <div class="code"><pre>$ go mod tidy
$ go list -m all
example.com/hello
golang.org/x/text v0.3.0
rsc.io/quote/v3 v3.1.0
rsc.io/sampler v1.3.1
$ cat go.mod
module example.com/hello

go 1.12

require (
    golang.org/x/text v0.3.0 // indirect
    rsc.io/quote/v3 v3.1.0
    rsc.io/sampler v1.3.1 // indirect
)

$ go test
PASS
ok      example.com/hello    0.020s
$</pre></div>
  


    
      
  <h4 id="TOC_8.">Conclusion</h4>
  
  
  <p>
    Go modules are the future of dependency management in Go.


    Module functionality is now available in all supported Go versions


    (that is, in Go 1.11 and Go 1.12).
  </p>
  

  
  <p>
    This post introduced these workflows using Go modules:
  </p>
  

  <ul>
  
    <li><code>go mod init</code> creates a new module, initializing the <code>go.mod</code> file that describes it.</li>
  
    <li><code>go build</code>, <code>go test</code>, and other package-building commands add new dependencies to <code>go.mod</code> as needed.</li>
  
    <li><code>go list -m all</code> prints the current module’s dependencies.</li>
  
    <li><code>go get</code> changes the required version of a dependency (or adds a new dependency).</li>
  
    <li><code>go mod tidy</code> removes unused dependencies.</li>
  
  </ul>

  
  <p>
    We encourage you to start using modules in your local development


    and to add <code>go.mod</code> and <code>go.sum</code> files to your projects.


    To provide feedback and help shape the future of dependency management in Go,


    please send us


    <a href="https://golang.org/issue/new" target="_blank">bug reports</a> or <a href="https://golang.org/wiki/ExperienceReports" target="_blank">experience reports</a>.
  </p>
  

  
  <p>
    Thanks for all your feedback and help improving modules.
  </p>
  


    
  


		
			<p class="author">By Tyler Bui-Palsulich and Eno Compton</p>
		
	</div>

	
		
	<div class="article" data-slug="/go-developer-network">
		<h3 class="title"><a href="/go-developer-network">The New Go Developer Network</a></h3>
		<p class="date">14 March 2019</p>
		

  
  
    
      
        
  
  <p>
    A sense of community flourishes when we come together in person. As handles become names


    and avatars become faces, the smiles are real and true friendship can grow. There is joy


    in the sharing of knowledge and celebrating the accomplishments of our friends, colleagues,


    and neighbors. In our rapidly growing Go community this critical role is played by the


    Go user groups.
  </p>
  

      
        
  
  <p>
    To better support our Go user groups worldwide, the Go community leaders at <a href="https://gobridge.org" target="_blank">GoBridge</a>


    and Google have joined forces to create a new program called the Go Developer Network


    (GDN). The GDN is a collection of Go user groups working together with a shared mission


    to empower developer communities with the knowledge, experience, and wisdom to build


    the next generation of software in Go.
  </p>
  

      
        
  
  <p>
    We have partnered with Meetup to create our own <a href="https://meetup.com/pro/go" target="_blank">Pro Network of Go Developers</a>


    providing Go developers a single place to search for local user groups, events, and


    see what other Gophers are doing around the world.
  </p>
  

      
        
  
  <p>
    User groups that join the GDN will be recognized by GoBridge as the official user group


    for that city and be provided with the latest news, information, conduct policies, and


    procedures. GDN groups will have Meetup fees paid by the GDN and will have access to


    special swag and other fun items. Each organizer of a GDN local group will continue to


    own the group and maintain full admin rights. <b>If you currently run a user group</b>,


    please fill out this <a href="https://j.mp/gdn-form" target="_blank">application</a> to request to join the GDN.
  </p>
  

      
        
  
  <p>
    We hope you are as excited about the GDN as we are.
  </p>
  

      
    
  


		
			<p class="author">By GoBridge Leadership Team</p>
		
	</div>

	
		
	<div class="article" data-slug="/gcdk-whats-new-in-march-2019">
		<h3 class="title"><a href="/gcdk-whats-new-in-march-2019">What&#39;s new in the Go Cloud Development Kit</a></h3>
		<p class="date">4 March 2019</p>
		

  
  
    
      
  <h4 id="TOC_1.">Introduction</h4>
  
  
  <p>
    Last July, we <a href="https://blog.golang.org/go-cloud" target="_blank">introduced</a> the <a href="https://gocloud.dev" target="_blank">Go Cloud Development Kit</a> (previously referred to as simply &#34;Go Cloud&#34;), an open source project building libraries and tools to improve the experience of developing for the cloud with Go. We&#39;ve made a lot of progress since then -- thank you to early contributors! We look forward to growing the Go CDK community of users and contributors, and are excited to work closely with early adopters.
  </p>
  


    
      
  <h4 id="TOC_2.">Portable APIs</h4>
  
  
  <p>
    Our first initiative is a set of portable APIs for common cloud services. You write your application using these APIs, and then deploy it on any combination of providers, including AWS, GCP, Azure, on-premise, or on a single developer machine for testing. Additional providers can be added by implementing an interface.
  </p>
  

  
  <p>
    These portable APIs are a great fit if any of the following are true:
  </p>
  

  <ul>
  
    <li>You develop cloud applications locally.</li>
  
    <li>You have on-premise applications that you want to run in the cloud (permanently, or as part of a migration).</li>
  
    <li>You want portability across multiple clouds.</li>
  
    <li>You are creating a new Go application that will use cloud services.</li>
  
  </ul>

  
  <p>
    Unlike traditional approaches where you would need to write new application code for each cloud provider, with the Go CDK you write your application code once using our portable APIs to access the set of services listed below. Then, you can run your application on any supported cloud with minimal config changes.
  </p>
  

  
  <p>
    Our current set of APIs includes:
  </p>
  

  <ul>
  
    <li><a href="https://godoc.org/gocloud.dev/blob" target="_blank">blob</a>, for persistence of blob data. Supported providers include: AWS S3, Google Cloud Storage (GCS), Azure Storage, the filesystem, and in-memory.</li>
  
    <li><a href="https://godoc.org/gocloud.dev/pubsub" target="_blank">pubsub</a> for publishing/subscribing of messages to a topic. Supported providers include: Amazon SNS/SQS, Google Pub/Sub, Azure Service Bus, RabbitMQ, and in-memory.</li>
  
    <li><a href="https://godoc.org/gocloud.dev/runtimevar" target="_blank">runtimevar</a>, for watching external configuration variables. Supported providers include AWS Parameter Store, Google Runtime Configurator, etcd, and the filesystem.</li>
  
    <li><a href="https://godoc.org/gocloud.dev/secrets" target="_blank">secrets</a>, for encryption/decryption. Supported providers include AWS KMS, GCP KMS, Hashicorp Vault, and local symmetric keys.</li>
  
    <li>Helpers for connecting to cloud SQL providers. Supported providers include AWS RDS and Google Cloud SQL.</li>
  
    <li>We are also working on a document storage API (e.g. MongoDB, DynamoDB, Firestore).</li>
  
  </ul>


    
      
  <h4 id="TOC_3.">Feedback</h4>
  
  
  <p>
    We hope you&#39;re as excited about the Go CDK as we are -- check out our <a href="https://godoc.org/gocloud.dev" target="_blank">godoc</a>, walk through our <a href="https://github.com/google/go-cloud/tree/master/samples/tutorial" target="_blank">tutorial</a>, and use the Go CDK in your application(s). We&#39;d love to hear your ideas for other APIs and API providers you&#39;d like to see.
  </p>
  

  
  <p>
    If you&#39;re digging into Go CDK please share your experiences with us:
  </p>
  

  <ul>
  
    <li>What went well?</li>
  
    <li>Were there any pain points using the APIs?</li>
  
    <li>Are there any features missing in the API you used?</li>
  
    <li>Suggestions for documentation improvements.</li>
  
  </ul>

  
  <p>
    To send feedback, you can:
  </p>
  

  <ul>
  
    <li>Submit issues to our public <a href="https://github.com/google/go-cloud/issues/new/choose" target="_blank">GitHub repository</a>.</li>
  
    <li>Email <a href="mailto:go-cdk-feedback@google.com" target="_blank">go-cdk-feedback@google.com</a>.</li>
  
    <li>Post to our <a href="https://groups.google.com/forum/#!forum/go-cloud" target="_blank">public Google group</a>.</li>
  
  </ul>

  
  <p>
    Thanks!
  </p>
  


    
  


		
			<p class="author">By The Go Cloud Development Kit team at Google, Twitter #GoCDK</p>
		
	</div>

	
	<p>See the <a href="/index">index</a> for more articles.

</div>

<div id="footer">
	<p>
	Except as
	<a href="https://developers.google.com/site-policies#restrictions">noted</a>,
	the content of this page is licensed under the Creative Commons
	Attribution 3.0 License,<br>
	and code is licensed under a <a href="https://golang.org/LICENSE">BSD license</a>.<br>
	<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
	<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a> |
	<a href="https://go.googlesource.com/blog/">View the source code</a>
	</p>
</div>

</div>
</div>

</body>
<script src="/lib/godoc/jquery.js"></script>
<script src="/lib/godoc/playground.js"></script>
<script src="/lib/godoc/play.js"></script>
<script src="/lib/godoc/godocs.js"></script>
<script>
$(function() {
	
	$('.playground > pre.numbers, .code > pre.numbers').each(function() {
		var $spans = $(this).find('> span');

		
		var max = 0;
		$spans.each(function() {
			var n = $(this).attr('num')*1;
			if (n > max) max = n;
		});
		var width = 2;
		while (max > 10) {
			max = max / 10;
			width++;
		}

		
		$spans.each(function() {
			var n = $(this).attr('num')+' ';
			while (n.length < width) n = ' '+n;
			$('<span class="number">').text(n).insertBefore(this);
		});
	});

	initPlayground(new HTTPTransport());
});
</script>
</html>
